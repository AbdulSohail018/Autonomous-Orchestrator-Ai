name: Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'README.md'
      - 'docs/**'
      - '**/*.py'
  pull_request:
    branches: [ main ]
    paths:
      - 'README.md'
      - 'docs/**'
      - '**/*.py'

jobs:
  docs-validation:
    name: Documentation Validation
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"

    - name: Install documentation tools
      run: |
        pip install markdownlint-cli2 pydocstyle

    - name: Validate README structure
      run: |
        echo "ðŸ“– Validating README.md structure..."
        
        # Check for required sections
        required_sections=(
          "Architecture"
          "Quick Start" 
          "Configuration"
          "Troubleshooting"
          "Installation"
          "Usage"
        )
        
        missing_sections=""
        for section in "${required_sections[@]}"; do
          if ! grep -qi "## .*$section" README.md; then
            missing_sections="$missing_sections $section"
          fi
        done
        
        if [ -n "$missing_sections" ]; then
          echo "âŒ Missing required sections: $missing_sections"
          exit 1
        else
          echo "âœ… All required sections present"
        fi

    - name: Check code documentation coverage
      run: |
        echo "ðŸ“ Checking Python docstring coverage..."
        
        python -c "
        import ast
        import os
        import sys
        
        def check_docstring_coverage(directory):
            total_items = 0
            documented_items = 0
            
            for root, dirs, files in os.walk(directory):
                # Skip test directories and __pycache__
                dirs[:] = [d for d in dirs if not d.startswith('__pycache__') and not d.startswith('.')]
                
                for file in files:
                    if file.endswith('.py') and not file.startswith('test_'):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                tree = ast.parse(f.read())
                            
                            for node in ast.walk(tree):
                                if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
                                    # Skip private methods and special methods
                                    if not node.name.startswith('_'):
                                        total_items += 1
                                        if ast.get_docstring(node):
                                            documented_items += 1
                                        else:
                                            print(f'Missing docstring: {file_path}:{node.lineno} - {node.name}')
                        except Exception as e:
                            print(f'Error parsing {file_path}: {e}')
            
            return total_items, documented_items
        
        # Check documentation coverage for key directories
        directories = ['agent', 'ops', 'kafka/producer']
        total_all = 0
        documented_all = 0
        
        for directory in directories:
            if os.path.exists(directory):
                total, documented = check_docstring_coverage(directory)
                total_all += total
                documented_all += documented
                
                if total > 0:
                    coverage = (documented / total) * 100
                    print(f'{directory}: {documented}/{total} ({coverage:.1f}%)')
                else:
                    print(f'{directory}: No items found')
        
        if total_all > 0:
            overall_coverage = (documented_all / total_all) * 100
            print(f'Overall documentation coverage: {documented_all}/{total_all} ({overall_coverage:.1f}%)')
            
            if overall_coverage < 70:
                print('âŒ Documentation coverage below 70%')
                sys.exit(1)
            else:
                print('âœ… Documentation coverage acceptable')
        "

    - name: Validate Markdown formatting
      run: |
        echo "ðŸ” Validating Markdown formatting..."
        
        # Create markdownlint config
        cat > .markdownlint.json << 'EOF'
        {
          "MD013": {
            "line_length": 120,
            "tables": false
          },
          "MD033": false,
          "MD041": false
        }
        EOF
        
        # Run markdownlint
        npx markdownlint-cli2 "README.md" || echo "Markdown linting completed with warnings"

    - name: Check for broken internal links
      run: |
        echo "ðŸ”— Checking for broken internal links..."
        
        python -c "
        import re
        import os
        
        def check_internal_links(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Find internal links [text](file.md#section)
            internal_links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)
            broken_links = []
            
            for link_text, link_path in internal_links:
                # Skip external links
                if link_path.startswith('http'):
                    continue
                
                # Check if file exists (simple check for now)
                if '#' in link_path:
                    file_part = link_path.split('#')[0]
                else:
                    file_part = link_path
                
                if file_part and not os.path.exists(file_part):
                    broken_links.append(f'{link_text} -> {link_path}')
            
            return broken_links
        
        broken = check_internal_links('README.md')
        if broken:
            print('âŒ Broken internal links found:')
            for link in broken:
                print(f'  - {link}')
        else:
            print('âœ… No broken internal links found')
        "

    - name: Validate architecture diagram
      run: |
        echo "ðŸ—ï¸ Validating architecture diagram..."
        
        # Check if Mermaid diagram is present and valid
        if grep -q "```mermaid" README.md; then
          echo "âœ… Mermaid diagram found in README"
          
          # Extract diagram and basic validation
          python -c "
          import re
          
          with open('README.md', 'r') as f:
              content = f.read()
          
          # Find mermaid blocks
          mermaid_blocks = re.findall(r'```mermaid\n(.*?)\n```', content, re.DOTALL)
          
          if mermaid_blocks:
              diagram = mermaid_blocks[0]
              
              # Basic validation - check for key components
              required_components = ['Kafka', 'Spark', 'Airflow', 'Agent']
              missing_components = []
              
              for component in required_components:
                  if component.lower() not in diagram.lower():
                      missing_components.append(component)
              
              if missing_components:
                  print(f'âš ï¸ Architecture diagram missing components: {missing_components}')
              else:
                  print('âœ… Architecture diagram includes all key components')
          else:
              print('âŒ No Mermaid diagram content found')
          "
        else
          echo "âŒ No Mermaid architecture diagram found in README"
        fi

  generate-api-docs:
    name: Generate API Documentation
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"

    - name: Install documentation dependencies
      run: |
        pip install -r agent/requirements.txt
        pip install pdoc3 sphinx

    - name: Generate API documentation
      run: |
        echo "ðŸ“š Generating API documentation..."
        
        # Create docs directory
        mkdir -p docs/api
        
        # Generate documentation for key modules
        modules_to_document=(
          "agent.decision_agent"
          "agent.tools" 
          "ops.notifications"
          "ops.incident_store"
        )
        
        for module in "${modules_to_document[@]}"; do
          if [ -f "${module//./\/}.py" ]; then
            echo "Documenting $module..."
            python -m pdoc --html --output-dir docs/api "$module" || echo "Failed to document $module"
          fi
        done

    - name: Create documentation index
      run: |
        cat > docs/README.md << 'EOF'
        # Documentation
        
        This directory contains auto-generated and manual documentation for the Autonomous Data Pipeline Orchestrator.
        
        ## ðŸ“š Available Documentation
        
        ### API Documentation
        - [Decision Agent](api/agent/decision_agent.html) - Core autonomous decision making logic
        - [Tools](api/agent/tools.html) - Remediation tools and actions
        - [Notifications](api/ops/notifications.html) - Alert and notification system
        - [Incident Store](api/ops/incident_store.html) - Incident management and tracking
        
        ### Architecture
        - [System Architecture](../README.md#architecture) - High-level system design
        - [Decision Matrix](../README.md#decision-matrix) - Agent decision logic
        - [Configuration Guide](../README.md#configuration) - Setup and configuration
        
        ### Operations
        - [Deployment Guide](../README.md#production-deployment) - Production deployment
        - [Monitoring](../README.md#monitoring--observability) - Monitoring and observability
        - [Troubleshooting](../README.md#troubleshooting) - Common issues and solutions
        
        ---
        *Documentation generated automatically on $(date)*
        EOF

    - name: Upload documentation artifacts
      uses: actions/upload-artifact@v3
      with:
        name: api-documentation
        path: docs/

  spell-check:
    name: Spell Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Install spell checker
      run: |
        sudo apt-get update
        sudo apt-get install -y aspell aspell-en

    - name: Create spell check wordlist
      run: |
        cat > .aspell.en.pws << 'EOF'
        personal_ws-1.1 en 100
        Airflow
        Kafka
        Snowflake
        LangChain
        Ollama
        PostgreSQL
        Dockerfile
        Kubernetes
        API
        UI
        CLI
        JSON
        YAML
        SQL
        CSV
        Parquet
        AVRO
        ETL
        ML
        AI
        DevOps
        DataOps
        MLOps
        config
        configs
        remediation
        orchestrator
        scalability
        observability
        webhook
        webhooks
        runtime
        metadata
        schemas
        timestamp
        timestamps
        middleware
        microservice
        microservices
        auth
        localhost
        workflow
        workflows
        Github
        Kubernetes
        namespace
        namespaces
        EOF

    - name: Run spell check on README
      run: |
        echo "ðŸ”¤ Running spell check on documentation..."
        
        # Check README.md
        aspell --personal=.aspell.en.pws --mode=markdown --check README.md || echo "Spell check completed"
        
        # Check for common typos
        python -c "
        import re
        
        common_typos = {
            'recieve': 'receive',
            'seperate': 'separate', 
            'definately': 'definitely',
            'occured': 'occurred',
            'begining': 'beginning',
            'enviroment': 'environment',
            'perameter': 'parameter',
            'sucessful': 'successful'
        }
        
        with open('README.md', 'r') as f:
            content = f.read().lower()
        
        found_typos = []
        for typo, correct in common_typos.items():
            if typo in content:
                found_typos.append(f'{typo} -> {correct}')
        
        if found_typos:
            print('âš ï¸ Common typos found:')
            for typo in found_typos:
                print(f'  - {typo}')
        else:
            print('âœ… No common typos found')
        "

  docs-coverage-report:
    name: Documentation Coverage Report
    runs-on: ubuntu-latest
    needs: [docs-validation, generate-api-docs, spell-check]
    if: always()
    
    steps:
    - name: Create documentation report
      run: |
        cat > docs-report.md << 'EOF'
        # ðŸ“– Documentation Quality Report
        
        **Generated:** $(date)
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        
        ## ðŸ“Š Validation Results
        
        | Check | Status |
        |-------|--------|
        | README Structure | ${{ needs.docs-validation.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |
        | API Documentation | ${{ needs.generate-api-docs.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |
        | Spell Check | ${{ needs.spell-check.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |
        
        ## ðŸ“ Documentation Checklist
        
        - [x] README.md exists and is comprehensive
        - [x] Architecture diagram included
        - [x] Quick start guide provided
        - [x] Configuration documentation complete
        - [x] Troubleshooting section available
        - [x] API documentation generated
        - [x] Code comments and docstrings
        
        ## ðŸš€ Recommendations
        
        - Keep documentation up-to-date with code changes
        - Add more code examples for complex features
        - Consider adding video tutorials for setup
        - Expand troubleshooting section based on user feedback
        
        ---
        *Report generated by documentation workflow*
        EOF

    - name: Upload documentation report
      uses: actions/upload-artifact@v3
      with:
        name: documentation-report
        path: docs-report.md

    - name: Comment PR with documentation status
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          let message = '## ðŸ“– Documentation Quality Report\n\n';
          
          message += `| Check | Status |\n`;
          message += `|-------|--------|\n`;
          message += `| Validation | ${{ needs.docs-validation.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |\n`;
          message += `| API Docs | ${{ needs.generate-api-docs.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |\n`;
          message += `| Spell Check | ${{ needs.spell-check.result == 'success' && 'âœ… PASS' || 'âŒ FAIL' }} |\n`;
          
          message += '\nðŸ“ Documentation has been validated and is ready for review!\n';
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          });